package backend.files.csv;

import backend.config.Config;
import backend.files.File;
import java.io.IOException;
import java.util.ArrayList;


/**
 * This class implements a CSV file. It contains all the necessary information to handle file operations and provides
 * useful functionalities.
 * Instances of this class are always fully consistent. No matter which attribute you change, all attributes will always
 * be correct, much like a Java Bean.
 * <br><b><i>IMPORTANT:</i> These instances do not store the actual content of the respective files!</b>
 *
 * <br><b><i>MORE IMPORTANT: </i> The generic type &lt T &gt MUST have a default constructor!</b>
 *
 * @param <T>   Type that can be stored within this CSV file instance. This type <b>MUST</b> implement the
 *              {@linkplain CSVFileConvertible}-interface.
 * @author      Christian-2003
 * @version     01 June 2023
 */
public class CSVFile<T extends CSVFileConvertible> extends File {

    /**
     * Generates a new CSV File.
     *
     * @param path  Path to the CSV file.
     */
    public CSVFile(String path) {
        super(path);
    }


    /**
     * This method saves the CSV representations of the passed instances to the CSV file.
     * <br><b><i>IMPORTANT:</i> This method does NOT check whether the CSV generated by the passed instances is
     * syntactically correct!</b><br>
     *
     * @param instances     Instances to be saved to the CSV file.
     * @throws IOException  Some IO Error occurred.
     */
    public void saveCSV(T[] instances) throws IOException {
        //Generate the CSV:
        StringBuilder csv = new StringBuilder();
        for (T current : instances) {
            csv.append(current.toCSV());
            csv.append(Config.formats.lineSeparator);
        }

        //Save the csv:
        try {
            super.save(csv.toString());
        }
        catch (IOException e) {
            //Some IO Error occurred:
            throw e;
        }
    }

    /**
     * This method loads the CSV from the file and returns it as CSV Strings.
     *
     * @return                      Two-dimensional String-array containing the CSV cells:<br>
     *                              {@code String[y][x]}, where <i>y = row</i> and <i>x = column</i>.
     * @throws IOException          Some IO Error occurred.
     * @throws InvalidCSVException  The encountered CSV is syntactically incorrect.
     */
    public String[][] loadCSV() throws Exception, IOException, InvalidCSVException {
        String csv = load();

        String[] csvRows = csv.split(Config.formats.lineSeparator); //Stores the individual CSV rows.

        //Find number of actual rows:
        int numberOfRows = 0;
        for (String c : csvRows) {
            if (c != null && !c.equals("")) {
                numberOfRows++;
            }
        }

        if (numberOfRows == 0) {
            //No CSV to parse:
            return new String[0][0];
        }

        //Generate the first row of CSV to find the number of columns:
        String[] header = splitCSV(csvRows[0]);

        String[][] csvTable = new String[numberOfRows][header.length];

        //Parse the CSV for each row:
        for (int i = 1; i < numberOfRows; i++) {
            String[] currentRow = splitCSV(csvRows[i]);
            if (currentRow.length != header.length) {
                //Number of columns does not match:
                throw new InvalidCSVException("Number of columns in line " + (i + 1) + " does not match header row");
            }
            csvTable[i] = currentRow;
        }

        //Return the parsed CSV:
        return csvTable;
    }


    /**
     * This method splits a single CSV row into a String-array containing the row's CSV cells.
     *
     * @return                      String-array containing the CSV cells.
     * @throws InvalidCSVException  The encountered CSV is incorrect.
     */
    private String[] splitCSV(String csv) throws InvalidCSVException {
        ArrayList<String> cols = new ArrayList<String>();
        StringBuilder builder = new StringBuilder();
        boolean currentlyInCell = false;
        for (int i = 0; i < csv.length(); i++) {
            char currentChar = csv.charAt(i);
            if (currentChar == '"' && !currentlyInCell) {
                //Start of a new CSV cell:
                currentlyInCell = true;
            }
            else if (currentChar == '"' && currentlyInCell) {
                //End of a CSV cell:
                currentlyInCell = false;
                cols.add(builder.toString());
                builder.setLength(0); //"Clear" the StringBuilder.
            }
            else if (currentlyInCell) {
                builder.append(currentChar);
            }
            else {
                //Currently not in cell:
                if (currentChar != ';') {
                    throw new InvalidCSVException("Invalid character '" + currentChar + "' between CSV cells.");
                }
            }
        }

        if (currentlyInCell) {
            //Error: Last CSV cell never closed with '\"':
            throw new InvalidCSVException("Last CSV cell never ended");
        }

        //Return the columns as array:
        return toArray(cols);
    }


    /**
     * Converts the passed ArrayList of Strings into a String-array.
     *
     * @param strings   ArrayList of Strings to be converted into a String-array.
     * @return          String-array containing all elements of the passed ArrayList.
     */
    private String[] toArray(ArrayList<String> strings) {
        String[] array = new String[strings.size()];
        for (int i = 0; i < strings.size(); i++) {
            array[i] = strings.get(i);
        }
        return array;
    }

}
